/*
    WARNING:
        This file is automatically generated. Do not edit it directly!
*/
import {MessageType, WebsocketMessage} from "./websocket.type";
//%IMPORTS:START%
import {Workspace} from "./workspace";
//%IMPORTS:END%

export default class Client {

    ws: WebSocket | null = null;
    awaitingRes: Map<string, (args: string[]) => void>;
    awaitingRej: Map<string, (reason?: string) => void>;
    index: number;
    url: string;

    constructor(url?: string) {
        this.awaitingRes = new Map<string, (args: string[]) => void>();
        this.awaitingRej = new Map<string, (reason?: string) => void>();
        this.index = 0;
        if (url) {
            this.url = url
        } else if (typeof window !== 'undefined') {
            this.url = 'ws://' + window.location.host + '/ws/'
        } else {
            this.url = 'ws://127.0.0.1:31337/ws/'
        }
    }

    Init(): Promise<boolean> {
        return new Promise<boolean>((resolve, reject) => {
            let ready = false
            this.ws = new WebSocket(this.url);
            this.ws.onerror = (err) => {
                if (!ready) {
                    reject(err)
                }
            }
            this.ws.onopen = () => this.sendMessage({
                messageType: MessageType.Ping,
                identifier: 'client',
                args: [],
                sender: ''
            });
            this.ws.onmessage = data => {
                const message = <WebsocketMessage>JSON.parse(data.data);
                switch (message.messageType) {
                    case MessageType.Ping:
                        this.sendMessage({
                            messageType: MessageType.Pong,
                            identifier: message.identifier,
                            args: [],
                            sender: ''
                        })
                        break;
                    case MessageType.Pong:
                        if (!ready) {
                            ready = true
                            resolve(true)
                        }
                        break;
                    case MessageType.Result:
                        const prevResolve = this.awaitingRes.get(message.sender);
                        if (prevResolve != null) {
                            prevResolve.call(null, message.args);
                            this.awaitingRes.delete(message.sender);
                            this.awaitingRej.delete(message.sender);
                        }
                        break;
                    case MessageType.Failure:
                        const prevReject = this.awaitingRej.get(message.sender);
                        if (prevReject != null) {
                            let err: string = JSON.parse(message.args[0]);
                            prevReject.call(null, err);
                            this.awaitingRes.delete(message.sender);
                            this.awaitingRej.delete(message.sender);
                        }
                        break;
                    case MessageType.Notify:
                        break;
                    case MessageType.Error:
                        if (!ready) {
                            let err: string = JSON.parse(message.args[0]);
                            reject(err)
                        }
                        break;
                    default:
                        console.log(message);
                        break;
                }
            };
        })
    }

    close() {
        if (this.ws == null) {
            return;
        }
        this.ws.close();
        this.ws = null;
    }

    sendMessage(message: WebsocketMessage) {
        if (this.ws == null) {
            return;
        }
        this.ws.send(JSON.stringify(message));
    }

    callMethod(method: string, args: any[], receive: (args: string[]) => void, reject: (reason?: any) => void) {
        let sender = this.index.toString();
        this.index++
        this.awaitingRes.set(sender, receive);
        this.awaitingRej.set(sender, reject);
        for (let i = 0; i < args.length; i++) {
            args[i] = JSON.stringify(args[i])
        }
        this.sendMessage({
            messageType: MessageType.Method,
            identifier: method,
            args: args,
            sender: sender
        })
    }

//%METHODS:START%
    HelloWorld(): Promise<string> {
        return new Promise<string>((resolve, reject) => {
            const receive = (args: string[]) => {
                let output: string = JSON.parse(args[0]);
                resolve(output);
            }
            this.callMethod("HelloWorld", [], receive, reject);
        })
    }

    List(): Promise<string[]> {
        return new Promise<string[]>((resolve, reject) => {
            const receive = (args: string[]) => {
                let output: string[] = JSON.parse(args[0]);
                resolve(output);
            }
            this.callMethod("List", [], receive, reject);
        })
    }

    Test(): Promise<Workspace> {
        return new Promise<Workspace>((resolve, reject) => {
            const receive = (args: string[]) => {
                let output: Workspace = JSON.parse(args[0]);
                resolve(output);
            }
            this.callMethod("Test", [], receive, reject);
        })
    }

//%METHODS:END%

    /*
        Test(a: string): Promise<string> {
        let res: (value: string | PromiseLike<string>) => void;
        let rej: (reason?: any) => void;
        return new Promise<string>((resolve, reject) => {
            res = resolve;
            rej = reject;
            const receive = (args: string[]) => {
                let a: string = JSON.parse(args[0]);
                res(a);
            }
            this.callMethod("Test", [a], receive, rej);
        })

     */

}